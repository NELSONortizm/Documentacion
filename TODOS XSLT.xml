**ZOLL RunNumber	AgencyCaseNumbers.CaseNumber	
**Is construct by the rightmost 8 characters of the case number excluding the ‘-‘ For example. 2021-009876 becomes 21009876

<xsl:template name="SetRunNumber">
	<xsl:param name="Agency"/>
	<xsl:param name="DepartmentName"/>
	<xsl:variable name="Last_Agency_CaseNumber">
		<xsl:for-each select="Body/s0:CallEntry/s0:Responders/s0:Agency[child::*[local-name()='Agency' and text() = $Agency] and child::*[local-name()='DepartmentName' and text() = $DepartmentName]]/s0:AgencyCaseNumbers">
			<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
			<xsl:if test="position() = 1">
				<xsl:value-of select="./s0:CaseNumber"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:variable>
	<xsl:variable name="CaseNumber1">
		<xsl:value-of select="translate($Last_Agency_CaseNumber, '-','')"/>
	</xsl:variable>
	<xsl:element name="RunNumber">
		<xsl:value-of select="substring($CaseNumber1,string-length($CaseNumber1)-7)"/>
	</xsl:element>
</xsl:template>

***ZOL UnitStatus.StatusDate	"First DI UnitStatus.Status register according date and time.
The format must be Year-Month-DayTHour:Minutes:Seconds
2020-09-04T12:07:34"

<xsl:template name="SetStatusTime">
	<xsl:param name="Node"/>
	<xsl:param name="Status"/>
	<xsl:param name="SortOrder"/>
	<xsl:element name="{$Node}">
		<xsl:for-each select="./s0:UnitStatus/s0:Status[contains($Status, concat('*', text(), '*'))]/..">
			<xsl:sort select="./s0:Sequence" order="{$SortOrder}" data-type="number"/>
			<xsl:if test="position() = 1">
				<xsl:value-of select="substring(./s0:StatusDate,1,19)"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:element>
</xsl:template>

**ZOL UnitStatus.StatusDate	"First EN UnitStatus.Status register according date and time.
The format must be Year-Month-DayTHour:Minutes:Seconds
2020-09-04T12:07:34"
CON STATUS.DATE

<xsl:template name="SetStatusTime">
	<xsl:param name="Node"/>
	<xsl:param name="Status"/>
	<xsl:param name="SortOrder"/>
	<xsl:element name="{$Node}">
		<xsl:for-each select="./s0:UnitStatus/s0:Status[contains($Status, concat('*', text(), '*'))]/..">
			<xsl:sort select="./s0:Sequence" order="{$SortOrder}" data-type="number"/>
			<xsl:if test="position() = 1">
				<xsl:value-of select="substring(./s0:StatusDate,1,19)"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:element>
</xsl:template>

**ZOL NARRATIVE Narrative.Narrative	Must be contained on a <Remarks> node. All the narratives concatenated separated by two spaces. Only the first 1000 characters would be allowed

<Remarks>
		<xsl:variable name="Narratives">
			<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Call']/*[local-name()='Narrative']/*[local-name()='Narrative']">
				<xsl:choose>
					<xsl:when test="position() = last()">
						<xsl:value-of select="."/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat(.,'  ')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
		</xsl:variable>
		<xsl:element name="Narrative">
			<xsl:value-of select="substring($Narratives,1,1000)"/>
		</xsl:element>
	</Remarks>

**ZOLL AsociatedDepartments.ZoneFieldLevelx	The one before the lowest level (e.g. if 3 is the lowest geo level then this would be level 2) The department selected should be the one that matches with the Department of the event.

<xsl:template name="SetZone">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="Zone">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$DepartmentName]]/*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()-1]/text()"/>
		</xsl:element>
	</xsl:template>

**ZOLL
AsociatedDepartments.ZoneFieldLevelx	The ‘lowest level’ (a we can have levels 1 through 8 potentially being used) so this is the lowest level (e.g. if 3 is the lowest geo level then this would be level 3) The department selected should be the one that matches with the Department of the event .



***ZOLL LLAMADO API
<xsl:template name="SetDropOffAddress">
		<xsl:param name="Node"/>
		<xsl:param name="Status"/>
		<xsl:param name="SortOrder"/>
		<xsl:param name="apiUrl1"/>
		<xsl:param name="apiUrl2"/>
		<xsl:param name="callFullAddress"/>
		<xsl:param name="callCrosStreet1"/>
		<xsl:param name="callCrosStreet2"/>
		<xsl:element name="{$Node}">
			<xsl:for-each select="./s0:UnitStatus/s0:Status[contains($Status, concat('*',text(),'*'))]/..">
				<xsl:sort select="./s0:Sequence" order="{$SortOrder}" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:variable name="street" select="userCSharp:RepleaceSeveralSpacesbyOne(./s0:FullAddress)"/>
					<xsl:variable name="city" select="userCSharp:RepleaceSeveralSpacesbyOne(./s0:City)"/>
					<xsl:variable name="state" select="./s0:State"/>
					<xsl:variable name="apiUrl3" select="concat($apiUrl1,'street=',$street,'&amp;city=',$city,'&amp;state=',$state,$apiUrl2)"/>
					<xsl:element name="StreetAddress">
						<xsl:choose>
							<xsl:when test="$callFullAddress != ''">
								<xsl:value-of select="$callFullAddress"/>
							</xsl:when>
							<xsl:when test="$callCrosStreet1 != '' and  $callCrosStreet2 != ''">
								<xsl:value-of select="concat($callCrosStreet1,'',$callCrosStreet2)"/>
							</xsl:when>
							<xsl:when test="$callCrosStreet1 != ''">
								<xsl:value-of select="$callCrosStreet1"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="$callCrosStreet2"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:element>
					<xsl:element name="ZipCode">
						<xsl:value-of select="./s0:ZipCode"/>
					</xsl:element>
					<xsl:element name="City">
						<xsl:value-of select="./s0:City"/>
					</xsl:element>
					<xsl:element name="FacilityName">
						<xsl:value-of select="./s0:CommonName"/>
					</xsl:element>
					<xsl:element name="Zone">
						<xsl:value-of select="./*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()-1]/text()"/>
					</xsl:element>
					<xsl:element name="CensusTrack">
						<xsl:value-of select="ScriptNS1:CallCensusApiNoTask($apiUrl3,'tract')"/>
					</xsl:element>
					<xsl:element name="County">
						<xsl:value-of select="ScriptNS1:CallCensusApiNoTask($apiUrl3,'basename')"/>
					</xsl:element>
					<xsl:element name="State">
						<xsl:value-of select="./s0:State"/>
					</xsl:element>
					<xsl:element name="Grid">
						<xsl:value-of select="userCSharp:RemoveNonNumeric(./*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()]/text())"/>
					</xsl:element>
				</xsl:if>
			</xsl:for-each>
		</xsl:element>
	</xsl:template>

***ZOLL CREAR URL 
 public string CreateUrl(string street, string city, string state, string apiURL1, string apiURL2)
        {
            street = RepleaceSeveralSpacesbyOne(street.Trim());
            city = RepleaceSeveralSpacesbyOne(city.Trim());           
            string apiURl3 = apiURL1 + "street=" + street + "&city=" + city + "&state=" + state + apiURL2;
            return apiURl3;
        }
		
**ZOLL  UnitStatus.ZoneFieldLevelX 	The ‘lowest level’ (a we can have levels 1 through 8 potentially being used) so this is the lowest level (e.g. if 3 is the lowest geo level then this would be level 3) The UnitStatus Selected should be the last record where the status = AH,TH or TR

**FIREHOUSE 
AgencyCaseNumbers.CaseNumber	inci_no	Yes	"If the value has more than 7, the last 7 characters must be used with the two years digits and a dash (-), If has less zeros must be put at the left until have 7 digits.
For CAD it should be like this:
Case number: 2021-000057
To Firehouse 21-0000057
Se debera tomar el primer caseNumber asignado"

<xsl:template name="Template_inci_no">
		<xsl:param name="Agency"/>
		<xsl:param name="Department"/>
		<xsl:element name="inci_no">
			<xsl:variable name="casenumber" select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency' and child::*[local-name()='DepartmentName' and text()=$Department]]/*[local-name()='AgencyCaseNumbers' and child::*[local-name()='Agency' and text()=$Agency] and child::*[local-name()='Sequence' and text()=1]]/*[local-name()='CaseNumber']"/>
			<xsl:value-of select="substring($casenumber,3,3)"/>
			<xsl:variable name="numero" select="substring($casenumber,6)"/>
			<xsl:variable name="numero3" select="concat('0000000',$numero)"/>
			<xsl:value-of select="substring($numero3,string-length($numero3)-6,7)"/>
		</xsl:element>
	</xsl:template>Fgt

***FIREHOUSE Department.ZoneFieldLevel2

<xsl:element name="station">
		<xsl:variable name="departmentId" select="/*[local-name()='CAD_Message' ]/*[local-name()='Body' ]/*[local-name()='CallEntry' ]/*[local-name()='DepartmentID']"/>
		<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body' ]/*[local-name()='CallEntry' ]/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentID'] =$departmentId ]/*[local-name()='ZoneFieldLevel2']"/>
	</xsl:element>
  
 ***FIREHOUSE mutl_aid
  "N - None. Just one agency assigned
1 - Mutual aid received. First agency assigned
3 - Mutual aid given. Other acengies assigned"
<xsl:template name="Template_MultAID">
		<xsl:param name="Agency"/>
		<xsl:param name="Department"/>
		<xsl:element name="mutl_aid">
			<xsl:variable name="cont_agencias" select="count(/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency']/*[local-name()='DepartmentName' and text()=$Department])"/>
			<xsl:choose>
				<xsl:when test="$cont_agencias = 1">N</xsl:when>
				<xsl:otherwise>
					<xsl:choose>
						<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Responders']/*[local-name()='Agency' and child::*[local-name()='DepartmentName' and text()=$Department] and child::*[local-name()='Agency' and text()=$Agency] ]/*[local-name()='Sequence']=1">1</xsl:when>
						<xsl:otherwise>3</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>

***FIREHOUSE
Event.Dispatched	disp_date	No	Format MM/DD/YYYY
<xsl:element name="disp_time">
		<xsl:variable name="received" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Event' ]/*[local-name()='Dispatched']"/>
		<xsl:value-of select="substring($received,12,8)"/>
	</xsl:element>
  
FIREHOUSE narrative	No	"Every single narrative order by create date and separated by 2 spaces
Narrative.CreateDate (mm/dd/yyyy hh:mm:ss) + Narrative.Narrative"

<xsl:element name="narrative">
		<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
			<xsl:sort select="./s0:CreateDate" order="ascending" data-type="text"/>
			<xsl:value-of select="concat(substring(./s0:CreateDate,6,2),'/',substring(./s0:CreateDate,9,2),'/',substring(./s0:CreateDate,1,4),' ', substring(./s0:CreateDate,12,8),' ')"/>
			<xsl:value-of select="userCSharp:ReplaceEnter(./s0:Narrative)"/>
			<xsl:if test="position() != last()">
				<xsl:value-of select="'  '"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:element>

public string ReplaceEnter(string value)
{
	return value.Replace("\r\n", " ").Replace("\r", " ").Replace("\n", " ");
}

**FIREHOUSE PASA POR EL SERVICIO COMMON ULTIMA UNIDAD
UnitStatus.StatusDate	Notif_Date	No	"When UnitStatus.Status is DI
Format MM/DD/YYYY"

<xsl:element name="Notif_Date">
		<xsl:variable name="statusdatev" select="./*[local-name()='UnitStatus' and child::*[local-name()='Status']='DI']"/>
		<xsl:for-each select="$statusdatev">
			<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
			<xsl:if test="position() = 1">
				<xsl:variable name="date_" select="./s0:StatusDate"/>
				<xsl:value-of select="concat(substring($date_,6,2),'/',substring($date_,9,2),'/',substring($date_,1,4))"/>
			</xsl:if>
		</xsl:for-each>
	</xsl:element>
  
FIREHOUSE 
"Unit.BeginningMileage
Unit.EndingMileage"	Mileage	No	"Substraction between Unit.EndingMileage and Unit.BeginningMileage
Format: Mileage Miles Traveled (this incident) Float – 8 size"

<xsl:template name="Template_Mileage">
		<xsl:param name="beginning"/>
		<xsl:param name="ending"/>
		<xsl:element name="Mileage">
			<xsl:variable name="millas" select="$ending - $beginning"/>
			<xsl:if test="string(number($millas)) != 'NaN'">
				<xsl:value-of select="substring($millas,1,8)"/>
			</xsl:if>
		</xsl:element>
	</xsl:template>


***FIREHOUSE
CANCELLED	No	if the unit was not cleared (ie if there is no value un Unit.Clr_ Date then the unit was cancelled so this is a Y, if there is a clear date/time then this is N

  <xsl:element name="CANCELLED">
		<xsl:variable name="statusdatev" select="count(./*[local-name()='UnitStatus' and child::*[local-name()='Status']='CL'])"/>
		<xsl:choose>
			<xsl:when test="$statusdatev &gt; 0">N</xsl:when>
			<xsl:otherwise>Y</xsl:otherwise>
		</xsl:choose>
	</xsl:element>
  
 ***FIREHOUSE ESO
 UnitStatus.casenumber	"Is construct by the rightmost 2 digits of the first part of the case number and the rightmost 4 digits of the last part.
For example. 2021-009876 becomes 219876
Nota: Se toma el primer unitstatus.casenumber, siempre y cuando Unit.hasCaseNumber = True"
<xsl:template name="SetIncidentNumber">
		<xsl:param name="Agency"/>
		<xsl:param name="DepartmentName"/>
		<xsl:variable name="CaseNumber">
			<xsl:for-each select="Body/s0:CallEntry/s0:Responders/s0:Agency[child::*[local-name()='Agency' and text() = $Agency] and child::*[local-name()='DepartmentName' and text() = $DepartmentName]]/s0:AgencyCaseNumbers">
				<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:value-of select="./s0:CaseNumber"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:variable name="part1">
			<xsl:value-of select="substring-before($CaseNumber, '-')"/>
		</xsl:variable>
		<xsl:variable name="part2">
			<xsl:value-of select="substring-after($CaseNumber, '-')"/>
		</xsl:variable>
		<xsl:element name="IncidentNumber">
			<xsl:value-of select="substring($part1, string-length($part1) - 1)"/>-<xsl:value-of select="substring($part2, string-length($part2) - 3)"/>
		</xsl:element>
	</xsl:template>


**FIREHOUSE
DateTimeUnitEnRoute
UnitStatus.StatusDate
"First EN SystemCode register according date and time for this unit.
The format must be Year-Month-DayTHour:Minutes:Seconds
2020-10-22T12:04:00-04:00"

<xsl:template name="SetStatusTime">
		<xsl:param name="Node"/>
		<xsl:param name="Status"/>
		<xsl:param name="SortOrder"/>
		<xsl:element name="{$Node}">
			<xsl:for-each select="./s0:UnitStatus/s0:Status[contains($Status, concat('*',text(),'*'))]/..">
				<xsl:sort select="./s0:Sequence" order="{$SortOrder}" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:value-of select="./s0:StatusDate"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:element>
	</xsl:template>

**FIREHOUSE 
DateTimeUnitAtPatient	
UnitStatus.StatusDate	"Last AS-P SystemCode register according date and time for this unit.
The format must be Year-Month-DayTHour:Minutes:Seconds
2020-09-04T12:07:34"
<xsl:template name="SetStatusTime">
		<xsl:param name="Node"/>
		<xsl:param name="Status"/>
		<xsl:param name="SortOrder"/>
		<xsl:element name="{$Node}">
			<xsl:for-each select="./s0:UnitStatus/s0:Status[contains($Status, concat('*',text(),'*'))]/..">
				<xsl:sort select="./s0:Sequence" order="{$SortOrder}" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:value-of select="./s0:StatusDate"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:element>
	</xsl:template>

**FPN
<xsl:template name="Get_locationCS">
		<xsl:param name="call_cs1streetname"/>
		<xsl:param name="call_city"/>
		<xsl:param name="call_state"/>
		<xsl:param name="call_cs1tDirection"/>
		<xsl:param name="call_cs1Type"/>
		<xsl:param name="tuple_id"/>
		<xsl:param name="call_ZipCode"/>
		<eidd:CrossStreetByValue xmlns:eidd="http://eidd.nena.org">
			<presence xmlns="urn:ietf:params:xml:ns:pidf" xmlns:gp="urn:ietf:params:xml:ns:pidf:geopriv10" entity="pres:geotarget@example.com">
				<xsl:element name="tuple">
					<xsl:attribute name="id">
						<xsl:value-of select="$tuple_id"/>
					</xsl:attribute>
					<xsl:element name="status" namespace="urn:ietf:params:xml:ns:pidf">
						<gp:geopriv xmlns:gp="urn:ietf:params:xml:ns:pidf:geopriv10">
							<gp:location-info>
								<civicAddress xmlns="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr">
									<country>US</country>
									<A1>
										<xsl:value-of select="$call_state"/>
									</A1>
									<A3>
										<xsl:value-of select="$call_city"/>
									</A3>
									<A6>
										<xsl:value-of select="$call_cs1streetname"/>
									</A6>
									<PRD>
										<xsl:value-of select="$call_cs1tDirection"/>
									</PRD>
									<STS>
										<xsl:value-of select="$call_cs1Type"/>
									</STS>
									<xsl:if test="$call_ZipCode !='' ">
										<PC>
											<xsl:value-of select="$call_ZipCode"/>
										</PC>
									</xsl:if>
								</civicAddress>
							</gp:location-info>
							<gp:usage-rules/>
						</gp:geopriv>
					</xsl:element>
				</xsl:element>
			</presence>
		</eidd:CrossStreetByValue>
	</xsl:template>

**FPN ADDCODE

<xsl:template name="Get_location">
		<xsl:param name="call_streetname"/>
		<xsl:param name="call_city"/>
		<xsl:param name="call_state"/>
		<xsl:param name="call_streetDirection"/>
		<xsl:param name="call_streetType"/>
		<xsl:param name="call_houseNumber"/>
		<xsl:param name="department_id"/>
		<xsl:param name="call_Common"/>
		<xsl:param name="call_ZipCode"/>
		<xsl:param name="call_Suite"/>
		<xsl:element name="status" namespace="urn:ietf:params:xml:ns:pidf">
			<gp:geopriv xmlns:gp="urn:ietf:params:xml:ns:pidf:geopriv10">
				<gp:location-info>
					<civicAddress xmlns="urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr">
						<xsl:if test="$call_streetname !='' ">
							<country>US</country>
							<A1>
								<xsl:value-of select="$call_state"/>
							</A1>
							<A3>
								<xsl:value-of select="$call_city"/>
							</A3>
							<A6>
								<xsl:value-of select="$call_streetname"/>
							</A6>
							<PRD>
								<xsl:value-of select="$call_streetDirection"/>
							</PRD>
							<STS>
								<xsl:value-of select="$call_streetType"/>
							</STS>
							<HNO>
								<xsl:value-of select="$call_houseNumber"/>
							</HNO>
							<LMK>
								<xsl:value-of select="$call_Common"/>
							</LMK>
							<xsl:if test="$call_ZipCode !='' ">
								<PC>
									<xsl:value-of select="$call_ZipCode"/>
								</PC>
							</xsl:if>
							<UNIT>
								<xsl:value-of select="$call_Suite"/>
							</UNIT>
						</xsl:if>
						<xsl:if test="$call_streetname ='' and $call_ZipCode !='' ">
							<PC>
								<xsl:value-of select="$call_ZipCode"/>
							</PC>
						</xsl:if>
						<ADDCODE>
							<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$department_id] ]/*[contains(local-name(), 'ZoneFieldLevel') and text()!='']">
								<xsl:if test="position() = last()">
									<xsl:value-of select="."/>
								</xsl:if>
							</xsl:for-each>
						</ADDCODE>
					</civicAddress>
				</gp:location-info>
				<gp:usage-rules/>
			</gp:geopriv>
		</xsl:element>
	</xsl:template>

**SMTP PALABRAS RESERVADAS
<xsl:template name="Templ_ReemplazarPalabraReservada">
		<xsl:param name="param_texto"/>
		<xsl:param name="param_nodo"/>
		<xsl:param name="par_departmentId"/>
		<xsl:param name="lista_agenciasParametro"/>
		<xsl:element name="{$param_nodo}">
			<xsl:variable name="lista_agencias" select="ScriptNS1:construir_lista_agencia($lista_agenciasParametro)"/>
			<xsl:variable name="GetAgencyNames">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency']/*[local-name()='Agency' and (contains($lista_agencias, concat('*', text(), '*')) or $lista_agencias='' )]/../*[local-name()='AgencyName']">
					<xsl:value-of select="concat('*', .)"/>
				</xsl:for-each>*            
        </xsl:variable>
			<xsl:variable name="unitlist">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='AgencyName' and contains($GetAgencyNames,concat('*',text(),'*'))]/../*[local-name()='UnitName']/../*[local-name()='UnitStatus']/./*[local-name()='Status' and text()='DI']/..">
					<xsl:sort select="./s0:StatusDate" order="ascending" data-type="text"/>
					<xsl:value-of select="./s0:UnitName"/>
					<xsl:if test="position() &lt; last()">,</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			<xsl:variable name="Common">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Common']"/>
			</xsl:variable>
			<xsl:variable name="FullAddress">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='FullAddress']"/>
			</xsl:variable>
			<xsl:variable name="CrossStreet1">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='CrossStreet1']"/>
			</xsl:variable>
			<xsl:variable name="CrossStreet2">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='CrossStreet2']"/>
			</xsl:variable>
			<xsl:variable name="Zone">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$par_departmentId]]/*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()]/text()"/>
			</xsl:variable>
			<xsl:variable name="AllZones">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$par_departmentId]]/*[contains(local-name(), 'ZoneFieldLevel') and text()!='']">
					<xsl:value-of select="."/>
					<xsl:if test="position() &lt; last()">/</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			<xsl:variable name="Location">
				<xsl:value-of select="ScriptNS1:ConstruirLocation($Common,$FullAddress,$CrossStreet1,$CrossStreet2,'')"/>
			</xsl:variable>
			<xsl:variable name="LastUnitName">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='StatusDate']">
					<xsl:sort order="descending"/>
					<xsl:if test="position()=1">
						<xsl:value-of select="../*[local-name()='UnitName']"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:variable>
			<xsl:variable name="narrativas">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
					<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
					<xsl:variable name="narrativa" select="./s0:Narrative"/>
					<xsl:choose>
						<xsl:when test="substring($narrativa, string-length($narrativa),1) != '.' and substring($narrativa, string-length($narrativa),1) != ',' ">
							<xsl:value-of select="concat($narrativa,'. ')"/>
						</xsl:when>
						<xsl:when test="substring($narrativa, string-length($narrativa),1) = '.' or substring($narrativa, string-length($narrativa),1) = ',' ">
							<xsl:value-of select="concat($narrativa,' ')"/>
						</xsl:when>
					</xsl:choose>
				</xsl:for-each>
			</xsl:variable>
			<xsl:variable name="received" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Received']"/>
			<xsl:variable name="City" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='City']"/>
			<xsl:variable name="texto1" select="ScriptNS1:ReemplazarPalabraReservada('[EVENT#]',/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='EventNumber'],$param_texto)"/>
			<xsl:variable name="texto2" select="ScriptNS1:ReemplazarPalabraReservada('[CALLTYPE]',/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$par_departmentId]]/*[local-name()='CallType'],$texto1)"/>
			<xsl:variable name="texto3" select="ScriptNS1:ReemplazarPalabraReservada('[CALLTYPEDESC]',/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$par_departmentId]]/*[local-name()='CallTypeDescription'],$texto2)"/>
			<xsl:variable name="texto4" select="ScriptNS1:ReemplazarPalabraReservada('[RECDATETIME]',concat(substring($received,1,10),' ',substring($received,12,8)),$texto3)"/>
			<xsl:variable name="texto5" select="ScriptNS1:ReemplazarPalabraReservada('[ESPACE]',' ',$texto4)"/>
			<xsl:variable name="texto6" select="ScriptNS1:ReemplazarPalabraReservada('[LINE_JUMP]','NewLine',$texto5)"/>
			<xsl:variable name="texto7" select="ScriptNS1:ReemplazarPalabraReservada('[TAB]','Tab',$texto6)"/>
			<xsl:variable name="texto8" select="ScriptNS1:ReemplazarPalabraReservada('[LOCATION]',$Location,$texto7)"/>
			<xsl:variable name="texto9" select="ScriptNS1:ReemplazarPalabraReservada('[UNIT]',$LastUnitName,$texto8)"/>
			<!--  ** -->
			<xsl:variable name="texto10" select="ScriptNS1:ReemplazarPalabraReservada(concat('[ASSIGNED_UNITS:',$lista_agenciasParametro, ']'),$unitlist,$texto9)"/>
			<!-- ** -->
			<xsl:variable name="texto11" select="ScriptNS1:reemplazar_narrativa($narrativas, $texto10)"/>
			<xsl:variable name="texto12" select="ScriptNS1:ReemplazarPalabraReservada('[ZONE]',$Zone,$texto11)"/>
			<xsl:variable name="texto13" select="ScriptNS1:ReemplazarPalabraReservada('[ALLZONES]',$AllZones,$texto12)"/>
			<xsl:variable name="texto14" select="ScriptNS1:ReemplazarPalabraReservada('[CITY]',$City,$texto13)"/>
			<xsl:value-of select="$texto14"/>
		</xsl:element>
	</xsl:template>

*** POST 1 message	string		All the narratives concatenated separated by 2 spaces	Narrative.Narrative


<xsl:element name="message">
		<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
			<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
			<xsl:choose>
				<xsl:when test="position() = last()">
					<xsl:value-of select="./s0:Narrative"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(./s0:Narrative,'  ')"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:element>

*** post 3 All the narratives concatenated separated by 2 spaces	Narrative.Narrative

<xsl:element name="narratives">
		<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
			<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
			<xsl:choose>
				<xsl:when test="position() = last()">
					<xsl:value-of select="./s0:Narrative"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(./s0:Narrative,'  ')"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:element>

****unit_codes	string		comma delimited list of all the units on the event	Unit.UnitName
<xsl:element name="unit_codes">
		<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']">
			<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
			<xsl:choose>
				<xsl:when test="position() = last()">
					<xsl:value-of select="./s0:UnitName"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(./s0:UnitName,',')"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:for-each>
	</xsl:element>


***AsociatedDepartment.DepartmentName ***AsociatedDepartment.DepartmentName


<xsl:template name="SetPriority">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="Priority">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='AsociatedDepartment.DepartmentName']"/>
		</xsl:element>
	</xsl:template>



***AsociatedDepartment.DepartmentName

<xsl:template name="type">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="type">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='DepartmentName']"/>
		</xsl:element>
	</xsl:template>

***AsociatedDepartment.DepartmentName, AsociatedDepartment.CallType

<xsl:template name="type">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="type">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallType']"/>
		</xsl:element>
	</xsl:template>


***AsociatedDepartment.DepartmentName, AsociatedDepartment.CallTypeDescription

<xsl:template name="TmpCallTypeDescription">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="dispatch_type">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallTypeDescription']"/>
		</xsl:element>
	</xsl:template>

***AsociatedDepartment.DepartmentName, AsociatedDepartment.CallType

<xsl:template name="Tmpdispatch_incident_type_code">
		<xsl:param name="DepartmentName"/>
		<xsl:element name="dispatch_incident_type_code">
			<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallType']"/>
		</xsl:element>
	</xsl:template>




**COMMENTS NARRATIVE



<xsl:element name="Comments">
		<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
			<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
			<xsl:value-of select="concat(./s0:Narrative,'  ')"/>
		</xsl:for-each>
	</xsl:element>


**LOCATION SW, CONCATENAR callCrosStreet1 callCrosStreet1

<xsl:template name="SetLocation">
		<xsl:param name="callFullAddress"/>
		<xsl:param name="callCrosStreet1"/>
		<xsl:param name="callCrosStreet2"/>
		<xsl:element name="Location">
			<xsl:choose>
				<xsl:when test="$callFullAddress != ''">
					<xsl:value-of select="$callFullAddress"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat($callCrosStreet1,' and ',$callCrosStreet1)"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>


******AgencyCaseNumbers.CaseNumber

<xsl:template name="Tmpl_incident_number">
		<xsl:param name="Agency"/>
		<xsl:param name="DepartmentName"/>
		<xsl:variable name="CaseNumber">
			<xsl:for-each select="Body/s0:CallEntry/s0:Responders/s0:Agency[child::*[local-name()='Agency' and text() = $Agency] and child::*[local-name()='DepartmentName' and text() = $DepartmentName]]/s0:AgencyCaseNumbers">
				<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:value-of select="./s0:CaseNumber"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:variable>
		<xsl:element name="incident_number">
			<xsl:value-of select="$CaseNumber"/>
		</xsl:element>
	</xsl:template>

*****

<xsl:template name="Tmpalarm_at">
		<xsl:param name="callReceived"/>
		<xsl:element name="alarm_at">
			<xsl:choose>
				<xsl:when test="string-length($callReceived) &gt; 22">
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2),':',substring($callReceived,23,2))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2))"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>

**


*****
<xsl:template name="Tmpdispatch_notified_at">
		<xsl:param name="date"/>
		<xsl:element name="dispatch_notified_at">
			<xsl:value-of select="concat(substring($date,1,19),'+',substring($date,21,2),':',substring($date,23,2))"/>
		</xsl:element>
	</xsl:template>
**

2022-11-01T11:06:11.877
dispatch_notified_at
20240524102802

2022-11-01T11:07:23.203

********formatted datetime (YYYY-MM-DDTHH:MM:SS:Z)("2019-02-16T19:42:00+00:004")	Event.SentToDispatch

<xsl:element name="ns0:ReceivedTime">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME'] != ''">
		<xsl:variable name="received" select="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME']"/>
		<xsl:value-of select="concat(substring($received,1,4),'-',substring($received,5,2),'-',substring($received,7,2),'T',substring($received,9,2),':',substring($received,11,2),':',substring($received,13,2))"/>		
	</xsl:if>
</xsl:element>

,substring($received,13,2)
********
<xsl:element name="ns0:ReceivedDate">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME']"/>
	</xsl:if>
</xsl:element>
**
<xsl:template name="SetDateTime">
		<xsl:param name="pNodeName"/>
		<xsl:param name="pStatus"/>
		<xsl:param name="pSortOrder"/>
		<xsl:variable name="nombreultimaunidad">
			<xsl:choose>
				<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
					<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
						<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
						<xsl:if test="position() = 1">
							<xsl:value-of select="./*[local-name()='UnitName']"/>
						</xsl:if>
					</xsl:for-each>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:element name="{$pNodeName}">
			<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
				<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
				<xsl:if test="position() = 1">
					<xsl:value-of select="./*[local-name()='StatusDate']"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:element>
	</xsl:template>








*****************************omni911***************************
<xsl:template name="Tmpdispatch_notified_at">
		<xsl:param name="callReceived"/>
		<xsl:element name="dispatch_notified_at">
			<xsl:choose>
				<xsl:when test="string-length($callReceived) &gt; 22">
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2),':',substring($callReceived,23,2))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2))"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>
	
20240524102802
******* Year-Month-DayTHour:Minutes:Seconds 2020-09-04T12:07:34
2024-05-24T10:28:02


****
<xsl:template name="Tmpalarm_at">
		<xsl:param name="callReceived"/>
		<xsl:element name="alarm_at">
			<xsl:choose>
				<xsl:when test="string-length($callReceived) &gt; 22">
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2),':',substring($callReceived,23,2))"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2))"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>

******
<xsl:template name="Setcross_streets">
		<xsl:param name="callCrosStreet1"/>
		<xsl:param name="callCrosStreet2"/>
		<xsl:element name="cross_streets">
			<xsl:value-of select="concat($callCrosStreet1,' ',$callCrosStreet2)"/>
		</xsl:element>
	</xsl:template>

**** Call.Crossstreet1+" "+Call.CrossStreet2

<xsl:template name="Setcross_streets">
		<xsl:param name="callCrosStreet1"/>
		<xsl:param name="callCrosStreet2"/>
		<xsl:element name="cross_streets">
			<xsl:choose>
				<xsl:when test="$callCrosStreet1 != '' and $callCrosStreet2 != ''">
					<xsl:value-of select="concat($callCrosStreet1,' ',$callCrosStreet2)"/>
				</xsl:when>
				<xsl:when test="$callCrosStreet1 != '' and $callCrosStreet2 = ''">
					<xsl:value-of select="$callCrosStreet1"/>
				</xsl:when>
				<xsl:when test="$callCrosStreet1 = '' and $callCrosStreet2 !=''">
					<xsl:value-of select="$callCrosStreet2"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:element>
	</xsl:template>


**** ‘Received from @ CompPhoneArea - CompPhoneNumber CompExtNumber’

<xsl:template name="Setnotification_type">
		<xsl:param name="ReceivedFrom"/>
		<xsl:param name="CompPhoneArea"/>
		<xsl:param name="CompPhoneNumber"/>
		<xsl:param name="CompExtNumber"/>
		<xsl:element name="notification_type">
			<xsl:value-of select="concat($ReceivedFrom,'@',$CompPhoneArea,'-',$CompPhoneNumber,' ',$CompExtNumber)"/>
		</xsl:element>
	</xsl:template>
	<xsl:template name="Setnotification_type">
		<xsl:param name="ReceivedFrom"/>
		<xsl:param name="CompPhoneArea"/>
		<xsl:element name="CompPhoneNumber">
			<xsl:element name="CompExtNumber">
				<xsl:choose>
					<xsl:when test="$callCrosStreet1 != '' and $callCrosStreet2 != ''">
						<xsl:value-of select="concat($callCrosStreet1,' ',$callCrosStreet2)"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 != '' and $callCrosStreet2 = ''">
						<xsl:value-of select="$callCrosStreet1"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 = '' and $callCrosStreet2 !=''">
						<xsl:value-of select="$callCrosStreet2"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="''"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

****unit unit name en el cad.common llegando todas las unidades se extrae la ultima unidad con change status unit

<xsl:template name="SetUnitName">
			<xsl:param name="pNodeName"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:value-of select="$nombreultimaunidad"/>
			</xsl:element>
		</xsl:template>

**
***unit.name
<xsl:template name="SetUnitName">
			<xsl:param name="pNodeName"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:value-of select="$nombreultimaunidad"/>
			</xsl:element>
		</xsl:template>


*************** First Status = DI-P or DI (YYYY-MM-DDTHH:MM:SS:Z)	UnitStatus.StatusDate TOMADO DE UN XML CON VARIAS UNIDADES 
<xsl:template name="SetDateTime">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="statusvar">
							<xsl:value-of select="./*[local-name()='StatusDate']"/>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="string-length($statusvar) &gt; 22">
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>


*** POST 5 Last status before the unit were reassigned	Unitstatus.Status


/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Responders' ]/*[local-name()='Unit' ]/*[local-name()='UnitStatus' and child::*[local-name()='Sequence' and text() = /*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = 'pruebafire']]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*REASSIGN*', concat('*', text(), '*'))]]/*[local-name()='Sequence']-1]]/*[local-name()='Status']


*** canceled_stage_code	string		Last status before the unit were reassigned	Unitstatus.Status

<xsl:template name="Setcanceled_stage_code">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Responders' ]/*[local-name()='Unit' ]/*[local-name()='UnitStatus' and child::*[local-name()='Sequence' and text() = /*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]/*[local-name()='Sequence']-1]]/*[local-name()='Status']"/>
			</xsl:element>
		</xsl:template>
	
***enpoint 5 canceled_stage_code	string		if the unit has a AS status then send ‘on_scene’, if not then if the unit has a EN status then send ‘while_en_route’ else send ‘prior_to_en_route’.	Unitstatus.Status
<xsl:template name="TSetcanceled_stage_code">
			<xsl:param name="pNodeName"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*AS*', concat('*', text(), '*'))]]">
						<xsl:value-of select="'on_scene'"/>
					</xsl:when>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*EN*', concat('*', text(), '*'))]]">
						<xsl:value-of select="'while_en_route'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'prior_to_en_route'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>


*****is_aid	bool "False - if the agency of the sending is the first agency assigned  
True - if there are more than one agency and the agency of the sending is not the first dispatched"	True - False

False - if the agency of the sending is the first agency assigned 
True - if there are more than one agency and the agency of the sending is not the first dispatched

<xsl:template name="Tempis_aid">
			<xsl:param name="Agency"/>
			<xsl:param name="Department"/>
			<xsl:element name="is_aid">
				<xsl:variable name="cont_agencias" select="count(/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency']/*[local-name()='DepartmentName' and text()=$Department])"/>
				<xsl:choose>
					<xsl:when test="$cont_agencias = 1">false</xsl:when>
					<xsl:otherwise>
						<xsl:choose>
							<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Responders']/*[local-name()='Agency' and child::*[local-name()='DepartmentName' and text()=$Department] and child::*[local-name()='Agency' and text()=$Agency] ]/*[local-name()='Sequence']=1">false</xsl:when>
							<xsl:otherwise>true</xsl:otherwise>
						</xsl:choose>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>



******************MAPA ENDPOINT2************************
type	string	YES		AsociatedDepartment.DepartmentName

<xsl:template name="type">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="type">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='DepartmentName']"/>
			</xsl:element>
		</xsl:template>

message	string		All the narratives concatenated separated by 2 spaces	Narrative.Narrative


<xsl:element name="message">
			<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Narrative']">
				<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
				<xsl:value-of select="concat(./s0:Narrative,'  ')"/>
			</xsl:for-each>
		</xsl:element>

****unit_codes	string		comma delimited list of all the units on the event	Unit.UnitName

<xsl:element name="unit_codes">
			<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body' and namespace-uri()='']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']">
				<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
				<xsl:choose>
					<xsl:when test="position() = last()">
						<xsl:value-of select="./s0:UnitName"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat(./s0:UnitName,',')"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:for-each>
		</xsl:element>

***AsociatedDepartment.DepartmentName, AsociatedDepartment.CallType

<xsl:template name="type_code">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="type">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallType']"/>
			</xsl:element>
		</xsl:template>
		<xsl:template name="T_status_code">
			<xsl:param name="MessageType"/>
			<xsl:param name="MessageSubtype"/>
			<xsl:element name="status_code">
				<xsl:choose>
					<xsl:when test="$MessageType = 'Update Event'">Close</xsl:when>
					<xsl:otherwise>Open</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

***
<xsl:template name="T_status_code">
			<xsl:param name="MessageType"/>
			<xsl:param name="MessageSubtype"/>
			<xsl:element name="status_code">
				<xsl:choose>
					<xsl:when test="$MessageType = 'Update Event' and $MessageSubtype = 'Clear'">Close</xsl:when>
					<xsl:otherwise>Open</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

*****POST 4************* Department.CallTypeDescription

<xsl:template name="TmpCallTypeDescription">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="dispatch_type">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallTypeDescription']"/>
			</xsl:element>
		</xsl:template>

****POST 4 Department.CallType

<xsl:template name="type_code">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="incident_type_code">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[local-name()='DepartmentName' and text()=$DepartmentName]]/*[local-name()='CallType']"/>
			</xsl:element>
		</xsl:template>

**** POST 4 alarm_at	string		formatted datetime (YYYY-MM-DDTHH:MM:SS:Z) ("2019-02-16T19:42:00+00:004")

<xsl:template name="Tmpalarm_at">
			<xsl:param name="callReceived"/>
			<xsl:element name="alarm_at">
				<xsl:choose>
					<xsl:when test="string-length($callReceived) &gt; 22">
						<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2),':',substring($callReceived,23,2))"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="concat(substring($callReceived,1,19),'+',substring($callReceived,21,2))"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

**** POST 4 ‘Received from @ CompPhoneArea - CompPhoneNumber CompExtNumber’

<xsl:template name="Setnotification_type">
			<xsl:param name="ReceivedFrom"/>
			<xsl:param name="CompPhoneArea"/>
			<xsl:param name="CompPhoneNumber"/>
			<xsl:param name="CompExtNumber"/>
			<xsl:element name="notification_type">
				<xsl:value-of select="concat($ReceivedFrom,'@',$CompPhoneArea,'-',$CompPhoneNumber,' ',$CompExtNumber)"/>
			</xsl:element>
		</xsl:template>


---DA-PAGEV2 TEMPLATE RECURSIVO
**PARA MONSTRAR UN LISTADO : 123,125,126 ASÏ
**123
**125
<!-- This template accepts three inputs and creates the destination 
"Property" node.  Inside the template, it calls another template which 
builds up the potentially repeating "Value" child node -->
		<xsl:template name="WritePropertyNodeTemplate">
			<xsl:param name="Agency"/>
			<xsl:param name="Department"/>
			<xsl:param name="Target"/>
			<xsl:param name="Interface"/>
			<xsl:param name="CallType"/>
			<xsl:param name="to"/>
			<xsl:param name="message"/>
			<!-- create property node -->
			<Root>
				<!-- create single instance children nodes -->
				<Header>
					<Agency>
						<xsl:value-of select="$Agency"/>
					</Agency>
					<Department>
						<xsl:value-of select="$Department"/>
					</Department>
					<Target>
						<xsl:value-of select="$Target"/>
					</Target>
					<Interface>
						<xsl:value-of select="$Interface"/>
					</Interface>
					<CallType>
						<xsl:value-of select="$CallType"/>
					</CallType>
				</Header>
				<!-- call splitter template which accepts the "|" separated string -->
				<xsl:call-template name="StringSplit">
					<xsl:with-param name="val" select="$to"/>
				</xsl:call-template>
				<message>
					<xsl:value-of select="$message"/>
				</message>
			</Root>
		</xsl:template>
		<!-- This template accepts a string and pulls out the value before the 
designated delimiter -->
		<xsl:template name="StringSplit">
			<xsl:param name="val"/>
			<!-- do a check to see if the input string (still) has a "|" in it -->
			<xsl:choose>
				<xsl:when test="contains($val, ',')">
					<!-- pull out the value of the string before the "," delimiter -->
					<to>
						<xsl:value-of select="substring-before($val, ',')"/>
					</to>
					<!-- recursively call this template and pass in 
value AFTER the "|" delimiter -->
					<xsl:call-template name="StringSplit">
						<xsl:with-param name="val" select="substring-after($val, ',')"/>
					</xsl:call-template>
				</xsl:when>
				<xsl:otherwise>
					<!-- if there is no more delimiter values, print out 
the whole string -->
					<to>
						<xsl:value-of select="$val"/>
					</to>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:template>

***FIN TEMPLATE RECURSIVO

**************EPRO MAP*****************************

<xsl:template name="Crear_Envelope">
			<xsl:param name="soloporprecedencia"/>
			<data>
				<entries>
					<xsl:variable name="Last_Agency_CaseNumber">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency']/*[local-name()='AgencyCaseNumbers']/*[local-name()='CaseNumber']/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:CaseNumber"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$Last_Agency_CaseNumber !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.incident_number_1</xsl:attribute>
							<xsl:value-of select="$Last_Agency_CaseNumber"/>
						</xsl:element>
					</xsl:if>
					<xsl:element name="e">
						<xsl:attribute name="name">PrimeUnitCode</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitName']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.incident_date</xsl:attribute>
						<xsl:variable name="received" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Received']"/>
						<xsl:value-of select="concat(substring($received,6,2),'/',substring($received,9,2),'/',substring($received,1,4),' ',substring($received,12,8))"/>
					</xsl:element>
					<xsl:variable name="dispatched">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*DI*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$dispatched !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_2</xsl:attribute>
							<xsl:value-of select="concat(substring($dispatched,6,2),'/',substring($dispatched,9,2),'/',substring($dispatched,1,4),' ',substring($dispatched,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:variable name="enrouted">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*EN*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$enrouted !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_3</xsl:attribute>
							<xsl:value-of select="concat(substring($enrouted,6,2),'/',substring($enrouted,9,2),'/',substring($enrouted,1,4),' ',substring($enrouted,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:variable name="arrived">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*AS*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$arrived !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_4</xsl:attribute>
							<xsl:value-of select="concat(substring($arrived,6,2),'/',substring($arrived,9,2),'/',substring($arrived,1,4),' ',substring($arrived,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:variable name="statusdate1">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*TH*TR*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$statusdate1 !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_10</xsl:attribute>
							<xsl:value-of select="concat(substring($statusdate1,6,2),'/',substring($statusdate1,9,2),'/',substring($statusdate1,1,4),' ',substring($statusdate1,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:variable name="statusdate2">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*AH*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$statusdate2 !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_12</xsl:attribute>
							<xsl:value-of select="concat(substring($statusdate2,6,2),'/',substring($statusdate2,9,2),'/',substring($statusdate2,1,4),' ',substring($statusdate2,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:variable name="lastclear">
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']/*[local-name()='Status' and contains('*CL*',concat('*',text(),'*'))]/..">
							<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./s0:StatusDate"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:variable>
					<xsl:if test="$lastclear !=''">
						<xsl:element name="e">
							<xsl:attribute name="name">tbl_incident_data.time_13</xsl:attribute>
							<xsl:value-of select="concat(substring($lastclear,6,2),'/',substring($lastclear,9,2),'/',substring($lastclear,1,4),' ',substring($lastclear,12,8))"/>
						</xsl:element>
					</xsl:if>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.incident_street_number</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='HouseNumber']"/>
					</xsl:element>
					<xsl:variable name="house_number" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='HouseNumber']"/>
					<xsl:variable name="call_streetname" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='StreetName']"/>
					<xsl:variable name="call_streettype" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='StreetType']"/>
					<xsl:variable name="call_streetdirection" select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='StreetDirection']"/>
					<xsl:choose>
						<xsl:when test="$house_number =''">
							<xsl:element name="e">
								<xsl:attribute name="name">tbl_incident_data.Incident_street</xsl:attribute>
								<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='FullAddress']"/>
							</xsl:element>
						</xsl:when>
						<xsl:otherwise>
							<xsl:element name="e">
								<xsl:attribute name="name">tbl_incident_data.Incident_street</xsl:attribute>
								<xsl:value-of select="concat($call_streetname,' ',$call_streettype,' ',$call_streetdirection)"/>
							</xsl:element>
						</xsl:otherwise>
					</xsl:choose>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.Incident_street_suffix_number</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='Suite']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.zip</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='ZipCode']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data_2.scene_zone</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department']/*[local-name()='ZoneFieldLevel2']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data_2.shift</xsl:attribute>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_INCIDENT_DATA.User1</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department']/*[local-name()='ZoneFieldLevel1']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_INCIDENT_DATA.User2</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department']/*[local-name()='CallType']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.lat</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='LocationLatitude']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_incident_data.lon</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Call']/*[local-name()='LocationLongitude']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_INCIDENT_DATA.User3</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='AssignedArea']"/>
					</xsl:element>
					<xsl:element name="e">
						<xsl:attribute name="name">tbl_INCIDENT_DATA.User4</xsl:attribute>
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments']/*[local-name()='Department' and child::*[contains(local-name(), 'ZoneFieldLevel')]]/*[last()]"/>
					</xsl:element>
				</entries>
			</data>
		</xsl:template>

*************FIN EPRO MAP**************************
FIRST DUE MAPA 1 CAMPO ADDRESS
se cambia la forma en la que se estructura la dirección en el mapeo (adjunto versión 1.1)
La dirección deberá estar definida como:
          HouseNumber + ‘ ‘ + StreetName + ‘ ‘ + StreetType + ‘ ‘ + StreetDirection 
(si el campo que sigue tiene un valor use un separador de espacio)
Si StreetName esta vacío, deberemos usar la información correspondiente al crosstreet de la siguiente manera:
- Si cross street 1 y cross street 2 tienen valor <cross street 1> &
		<cross street 2> - Si cross street 1 solo tiene valor
		<cross street 1> - Si cross street 2 solo tiene valor
		<cross street 2> Si no se tiene StreetName o algun CrossStreet - Common 
***************FD ADDRESS*************************

		<xsl:template name="SetAddress">
			<xsl:param name="pHouseNumber"/>
			<xsl:param name="pStreetName"/>
			<xsl:param name="pStreetType"/>
			<xsl:param name="pStreetDirection"/>
			<xsl:param name="callCrosStreet1"/>
			<xsl:param name="callCrosStreet2"/>
			<xsl:param name="pCommon"/>
			<xsl:param name="LocationNotes"/>
			<xsl:element name="address">
				<xsl:choose>
					<xsl:when test="$pStreetName != ''">
						<xsl:value-of select="concat($pHouseNumber,' ',$pStreetName,' ',$pStreetType,' ',$pStreetDirection )"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 != '' and  $callCrosStreet2 != ''">
						<xsl:value-of select="concat($callCrosStreet1,' &amp; ',$callCrosStreet2)"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 != ''">
						<xsl:value-of select="$callCrosStreet1"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet2 != ''">
						<xsl:value-of select="$callCrosStreet2"/>
					</xsl:when>
					<xsl:when test="$pCommon != ''">
						<xsl:value-of select="$pCommon"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$LocationNotes"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

*******************FIN FD ADDRESS*****************
**fd mapa E2
status_code	string	YES	‘open' for all the cases but the sending where the condition at Step 3 matches.** Update Unit -Status = Clear => 'closed'	Open - Closed
****valida que haya por lo menos una unidad y que todas sean Unit.Status = RE o RE, si es así closed sino open
<xsl:template name="T_status_code">
			<xsl:param name="MessageType"/>
			<xsl:param name="MessageSubtype"/>
			<xsl:element name="status_code">
				<xsl:variable name="cont_units" select="count(/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit'])"/>
				<xsl:variable name="allUnitsClear">
					<xsl:value-of select="'Yes'"/>
					<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='Status']">
						<xsl:choose>
							<xsl:when test="contains('*CL*RE*',concat('*',text(),'*'))">
								<!-- <xsl:value-of select="'Yes'"/> -->
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="'No'"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</xsl:variable>
				<xsl:choose>
					<xsl:when test="$MessageType = 'Update Unit' and $MessageSubtype = 'Status' and $allUnitsClear = 'Yes' and $cont_units &gt; 0">closed</xsl:when>
					<xsl:otherwise>open</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>
********************************************************************


<xsl:template name="TSetcanceled_stage_code">
			<xsl:param name="pNodeName"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*AS*', concat('*', text(), '*'))]]">
						<xsl:value-of select="'on_scene'"/>
					</xsl:when>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*EN*', concat('*', text(), '*'))]]">
						<xsl:value-of select="'while_en_route'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'prior_to_en_route'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

******FD ENDPOIJT5


<xsl:template name="SetUnitName">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pnombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:value-of select="$pnombreultimaunidad"/>
			</xsl:element>
		</xsl:template>

****dispatch_at
<xsl:template name="SetDispatch">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>
***

<xsl:template name="Setarrive_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>
***
<xsl:template name="Setdispatch_acknowledged_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>
**

<xsl:template name="Setdenroute_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>

****
<xsl:template name="SetClearat">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>
**********
<xsl:template name="Setcanceled_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>

***
<xsl:template name="Setpatient_transferred_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="date_" select="./s0:StatusDate"/>
						<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>


****FIRERMS
  <xsl:element name="notified">
			<xsl:variable name="statusdatev" select="./*[local-name()='UnitStatus' and child::*[local-name()='Status']='DI']"/>
			<xsl:for-each select="$statusdatev">
				<xsl:sort select="./s0:Sequence" order="ascending" data-type="number"/>
				<xsl:if test="position() = 1">
					<xsl:variable name="date_" select="./s0:StatusDate"/>
					<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/>
				</xsl:if>
			</xsl:for-each>
		</xsl:element>
  ****
  
****ARRIVE_AT***

***
<xsl:template name="SetDateTime">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:variable name="nombreultimaunidad">
				<xsl:choose>
					<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit'] != ''">
						<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='ChangeStatusUnit']"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit']/*[local-name()='UnitStatus']">
							<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
							<xsl:if test="position() = 1">
								<xsl:value-of select="./*[local-name()='UnitName']"/>
							</xsl:if>
						</xsl:for-each>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:variable>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<xsl:variable name="statusvar">
							<xsl:value-of select="./*[local-name()='StatusDate']"/>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="string-length($statusvar) &gt; 22">
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>

****
<xsl:template name="Setpatient_transferred_at">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<!-- <xsl:variable name="date_" select="./s0:StatusDate"/>
				<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/> -->
						<xsl:variable name="statusvar">
							<xsl:value-of select="./*[local-name()='StatusDate']"/>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="string-length($statusvar) &gt; 22">
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>

*****FD5 ENVELOPE**************************************

<xsl:template name="Crear_Envelope_FD5_Units">
			<xsl:param name="soloporprecedencia"/>
			<xsl:param name="pAptSide"/>
			<xsl:variable name="vDepartment" select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='DepartmentName']"/>
			<xsl:variable name="vTarget" select="/*[local-name()='CAD_Message']/*[local-name()='Header']/*[local-name()='Target']"/>
			<xsl:variable name="AgencyID" select="/*[local-name() = 'CAD_Message']/*[local-name() = 'Header']/*[local-name() = 'AgencyName']"/>
			<xsl:variable name="AgencyName" select="/*[local-name() = 'CAD_Message']/*[local-name() = 'Body']/*[local-name() = 'CallEntry']/*[local-name() = 'Responders']/*[local-name() = 'Agency']/*[local-name() = 'Agency'  and text() = $AgencyID]/../*[local-name() = 'AgencyName' ]"/>
			<ns0:Envelope_PostapparatusesEndpoint5 xmlns:ns0="http://Mobiletec.Biztalk.FD.Schemas.Enevelope_PostapparatusesEndpoint5">
				<xsl:for-each select="/*[local-name() = 'CAD_Message']/*[local-name() = 'Body']/*[local-name() = 'CallEntry']/*[local-name() = 'Responders']/*[local-name() = 'Unit']/*[local-name() = 'AgencyName' and text() = $AgencyName]/..">
					<ns1:Root xmlns:ns1="http://Mobiletec.Biztalk.FD.Schemas.PostapparatusesEndpoint5">
						<Header>
							<xsl:element name="Agency">
								<xsl:value-of select="$AgencyID"/>
							</xsl:element>
							<xsl:element name="Department">
								<xsl:value-of select="$vDepartment"/>
							</xsl:element>
							<xsl:element name="Target">
								<xsl:value-of select="$vTarget"/>
							</xsl:element>
							<!-- <xsl:element name="HttpHeaders">
						
					</xsl:element>
					<xsl:element name="HttpMethodAndUrl">
						
					</xsl:element>
					<xsl:element name="SuppressMessageBodyForHttpVerbs">
						
					</xsl:element> -->
							<xsl:variable name="CaseNumber">
								<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency' and child::*[local-name()='Agency' and text() = $AgencyID] and child::*[local-name()='DepartmentName' and text() = $vDepartment]]/*[local-name()='AgencyCaseNumbers']">
									<xsl:sort select="./s0:Sequence" order="descending" data-type="number"/>
									<xsl:if test="position() = 1">
										<xsl:value-of select="./*[local-name()='CaseNumber']"/>
									</xsl:if>
								</xsl:for-each>
							</xsl:variable>
							<xsl:element name="incident_number">
								<xsl:value-of select="$CaseNumber"/>
							</xsl:element>
						</Header>
						<xsl:variable name="nombreunidad" select="./*[local-name()='UnitName']"/>
						<xsl:element name="unit_code">
							<xsl:value-of select="./*[local-name()='UnitName']"/>
						</xsl:element>
						<xsl:element name="is_aid">
							<xsl:variable name="cont_agencias" select="count(/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Agency']/*[local-name()='DepartmentName' and text()=$vDepartment])"/>
							<xsl:choose>
								<xsl:when test="$cont_agencias = 1">false</xsl:when>
								<xsl:otherwise>
									<xsl:choose>
										<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry' ]/*[local-name()='Responders']/*[local-name()='Agency' and child::*[local-name()='DepartmentName' and text()=$vDepartment] and child::*[local-name()='Agency' and text()=$AgencyID] ]/*[local-name()='Sequence']=1">false</xsl:when>
										<xsl:otherwise>true</xsl:otherwise>
									</xsl:choose>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:element>
						<xsl:element name="dispatch_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*DI*DI-P*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="arrive_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*AS*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="dispatch_acknowledged_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*DI*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="enroute_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*EN*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="clear_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*CL*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="back_in_service_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*CL*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="descending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="canceled_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*REASSIGN*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="patient_arrived_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pAptSide, concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="patient_transferred_at">
							<xsl:for-each select="./*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*AH*', concat('*', text(), '*'))]]">
								<xsl:sort select="./*[local-name()='StatusDate']" order="ascending" data-type="text"/>
								<xsl:if test="position() = 1">
									<xsl:variable name="statusvar">
										<xsl:value-of select="./*[local-name()='StatusDate']"/>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="string-length($statusvar) &gt; 22">
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2),':',substring($statusvar,23,2))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="concat(substring($statusvar,1,19),'+',substring($statusvar,21,2))"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:if>
							</xsl:for-each>
						</xsl:element>
						<xsl:element name="canceled_stage_code">
							<xsl:choose>
								<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*AS*', concat('*', text(), '*'))]]">
									<xsl:value-of select="'on_scene'"/>
								</xsl:when>
								<xsl:when test="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains('*EN*', concat('*', text(), '*'))]]">
									<xsl:value-of select="'while_en_route'"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="'prior_to_en_route'"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:element>
					</ns1:Root>
				</xsl:for-each>
			</ns0:Envelope_PostapparatusesEndpoint5>
		</xsl:template>


***FECHAS fd

<xsl:template name="Tmpalarm_at">
			<xsl:param name="callReceived"/>
			<xsl:param name="ptimezone"/>
			<xsl:element name="alarm_at">
				<xsl:value-of select="concat(substring($callReceived,1,19),$ptimezone)"/>
			</xsl:element>
		</xsl:template>
		<xsl:template name="Tmpdispatch_notified_at">
			<xsl:param name="callReceived"/>
			<xsl:param name="ptimezone"/>
			<xsl:element name="dispatch_notified_at">
				<xsl:value-of select="concat(substring($callReceived,1,19),$ptimezone)"/>
			</xsl:element>
		</xsl:template>

**

<xsl:template name="SetDispatch">
			<xsl:param name="pNodeName"/>
			<xsl:param name="pStatus"/>
			<xsl:param name="pSortOrder"/>
			<xsl:param name="nombreultimaunidad"/>
			<xsl:param name="ptimezone"/>
			<xsl:element name="{$pNodeName}">
				<xsl:for-each select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='Responders']/*[local-name()='Unit' and child::*[local-name()='UnitName' and text() = $nombreultimaunidad]]/*[local-name()='UnitStatus' and child::*[local-name()='Status' and contains($pStatus, concat('*', text(), '*'))]]">
					<xsl:sort select="./*[local-name()='StatusDate']" order="{$pSortOrder}" data-type="text"/>
					<xsl:if test="position() = 1">
						<!-- <xsl:variable name="date_" select="./s0:StatusDate"/>
				<xsl:value-of select="concat(substring($date_,1,4),'-',substring($date_,6,2),'-',substring($date_,9,15))"/> -->
						<xsl:variable name="statusvar">
							<xsl:value-of select="./*[local-name()='StatusDate']"/>
						</xsl:variable>
						<xsl:value-of select="concat(substring($statusvar,1,19),$ptimezone)"/>
					</xsl:if>
				</xsl:for-each>
			</xsl:element>
		</xsl:template>

***EN FIRERMS DISTRICT  --- LOWEST ZONFIELD LEVEL

<xsl:template name="SetDistrict">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="district">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$DepartmentName]]/*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()]/text()"/>
			</xsl:element>
		</xsl:template>

******FIREEMS EN CC address
<xsl:template name="SetAddress">
			<xsl:param name="pHouseNumber"/>
			<xsl:param name="pStreetName"/>
			<xsl:param name="pStreetType"/>
			<xsl:param name="pStreetDirection"/>
			<xsl:param name="callCrosStreet1"/>
			<xsl:param name="callCrosStreet2"/>
			<xsl:param name="pCommon"/>
			<xsl:param name="LocationNotes"/>
			<xsl:element name="address">
				<xsl:choose>
					<xsl:when test="$pStreetName != ''">
						<xsl:value-of select="concat($pHouseNumber,' ',$pStreetName,' ',$pStreetType,' ',$pStreetDirection )"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 != '' and  $callCrosStreet2 != ''">
						<xsl:value-of select="concat($callCrosStreet1,' &amp; ',$callCrosStreet2)"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet1 != ''">
						<xsl:value-of select="$callCrosStreet1"/>
					</xsl:when>
					<xsl:when test="$callCrosStreet2 != ''">
						<xsl:value-of select="$callCrosStreet2"/>
					</xsl:when>
					<xsl:when test="$pCommon != ''">
						<xsl:value-of select="$pCommon"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="$LocationNotes"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:element>
		</xsl:template>

**** FIREEMS AssociatedDepartments.ZoneFieldLevel	one before the last level
<xsl:template name="SetStation">
			<xsl:param name="DepartmentName"/>
			<xsl:element name="station">
				<xsl:value-of select="/*[local-name()='CAD_Message']/*[local-name()='Body']/*[local-name()='CallEntry']/*[local-name()='AssociatedDepartments' ]/*[local-name()='Department' and child::*[local-name()='DepartmentID' and text()=$DepartmentName]]/*[contains(local-name(), 'ZoneFieldLevel') and text()!=''][last()-1]/text()"/>
			</xsl:element>
		</xsl:template>
*** LATITUD IGUAL A CERO
***
Call.LocationLongitude	if the value is empty/blank/null should be set on 0
Call.LocationLatitude	if the value is empty/blank/null should be set on 1

<xsl:template name="SetLongitud1">
	<xsl:param name="plongitude"/>
	<xsl:element name="longitude">
		<xsl:choose>
			<xsl:when test="string(number($plongitude)) = 'NaN'">
				<xsl:value-of select="0"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$plongitude"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:element>
</xsl:template>

***

<xsl:template name="SetLatitud1">
	<xsl:param name="platitud"/>
	<xsl:element name="latitud">
		<xsl:choose>
			<xsl:when test="string(number($platitud)) = 'NaN'">
				<xsl:value-of select="1"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$platitud"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:element>
</xsl:template>

*****MAPA OMINI911 DE UN DICTIONARY PROPERTY KEY VALUE A UN ESQUEMA User Story 173107: OMNI 911 2. Mapping ***************
<xsl:element name="CommonName">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='CBN'] != '' ">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='CBN']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Address">
	<xsl:value-of select="concat(/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER'], ' ', /*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME'], ' ', /*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME_POST_TYPE'], ' ',/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER_SUFFIX'])"/>
</xsl:element>
<xsl:element name="HouseNumber">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER'] != '' ">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="StreetPart1">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME'] != '' ">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="StreetPart2">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME_POST_TYPE'] != '' ">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='STREET_NAME_POST_TYPE']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="StreetPart3">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER_SUFFIX'] != '' ">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='ADDRESS_NUMBER_SUFFIX']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Suite">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='LOCATION_DESCRIPTION'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='LOCATION_DESCRIPTION']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Area">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='POSTAL_COMMUNITY_NAME'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='POSTAL_COMMUNITY_NAME']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="ZipCode">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='POSTAL_CODE'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='POSTAL_CODE']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Notes1">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='ADDITIONAL_LOC_INFORMATION'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='ADDITIONAL_LOC_INFORMATION']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Latitude">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='LATITUDE'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='LATITUDE']"/>
	</xsl:if>
</xsl:element>
<xsl:element name="Longitude">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='LONGITUDE'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='LONGITUDE']"/>
	</xsl:if>
</xsl:element>
***

<xsl:element name="PhoneNumber">
	<xsl:variable name="Ani" select="/*[local-name()='data']/*[local-name()='property'][@key='$ANI']"/>
	<xsl:if test="string-length($Ani) &gt; 10">
		<xsl:value-of select="substring(/*[local-name()='data']/*[local-name()='property'][@key='$ANI'],4,string-length(/*[local-name()='data']/*[local-name()='property'][@key='$ANI']))"/>
	</xsl:if>
	<xsl:if test="string-length($Ani) = 10">
		<xsl:value-of select="substring(/*[local-name()='data']/*[local-name()='property'][@key='$ANI'],4,string-length(/*[local-name()='data']/*[local-name()='property'][@key='$ANI']))"/>
	</xsl:if>
	<xsl:if test="string-length($Ani) &lt; 10">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='$ANI']"/>
	</xsl:if>
</xsl:element>

<xsl:element name="PhoneArea">
	<xsl:variable name="Ani" select="/*[local-name()='data']/*[local-name()='property'][@key='$ANI']"/>
	<xsl:if test="string-length($Ani) &gt; 10">
		<xsl:value-of select="substring(/*[local-name()='data']/*[local-name()='property'][@key='$ANI'],1,3)"/>
	</xsl:if>
	<xsl:if test="string-length($Ani) = 10">
		<xsl:value-of select="substring(/*[local-name()='data']/*[local-name()='property'][@key='$ANI'],1,3)"/>
	</xsl:if>
</xsl:element>

<xsl:element name="Extension">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='MAP_ID'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='MAP_ID']"/>
	</xsl:if>
</xsl:element>

<xsl:element name="ReceivedDate">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME']"/>
	</xsl:if>
</xsl:element>


<xsl:element name="ReceivedTime">
	<xsl:if test="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME'] != ''">
		<xsl:value-of select="/*[local-name()='data']/*[local-name()='property'][@key='$REQUEST_TIME']"/>
	</xsl:if>
</xsl:element>

*****RAWDATA
<xsl:element name="RawDataNode">
	<xsl:value-of select="/*[local-name()='data']"/>
</xsl:element>
***

<xsl:element name="FirstName">
	<xsl:variable name="Customer" select="/*[local-name()='data']/*[local-name()='property'][@key='CUSTOMER_NAME']"/>
	<xsl:value-of select="userCSharp:SetCustomer($Customer,'firstname')"/>
</xsl:element>


<xsl:element name="LastName">
	<xsl:variable name="Customer" select="/*[local-name()='data']/*[local-name()='property'][@key='CUSTOMER_NAME']"/>
	<xsl:value-of select="userCSharp:SetCustomer($Customer,'lastname')"/>
</xsl:element>

<xsl:element name="MiddleName">
	<xsl:variable name="Customer" select="/*[local-name()='data']/*[local-name()='property'][@key='CUSTOMER_NAME']"/>
	<xsl:value-of select="userCSharp:SetCustomer($Customer,'middlename')"/>
</xsl:element>

<xsl:element name="Suffix">
	<xsl:variable name="Customer" select="/*[local-name()='data']/*[local-name()='property'][@key='CUSTOMER_NAME']"/>
	<xsl:value-of select="userCSharp:SetCustomer($Customer,'suffix')"/>
</xsl:element>

<xsl:element name="ns0:FirstName">
					<xsl:value-of select="userCSharp:SetCustomer($Customer,'firstname')"/>
				</xsl:element>
				<xsl:element name="ns0:LastName">
					<xsl:value-of select="userCSharp:SetCustomer($Customer,'lastname')"/>
				</xsl:element>
				<xsl:element name="ns0:MiddleName">
					<xsl:value-of select="userCSharp:SetCustomer($Customer,'middlename')"/>
				</xsl:element>
				<xsl:element name="ns0:Suffix">
					<xsl:value-of select="userCSharp:SetCustomer($Customer,'suffix')"/>
				</xsl:element>
				<xsl:element name="ns0:CommonName">
					<xsl:value-of select="userCSharp:SetCustomer($Customer,'commonname')"/>
				</xsl:element>
				<xsl:element name="ns0:FamilyName"/>


*****FIN MAPA OMINI911 DE UN DICTIONARY PROPERTY KEY VALUE A UN ESQUEMA

******************IT1 StreetName************************************
HouseNumber + ‘ ‘ + StreetName + ‘ ‘ + StreetType + ‘ ‘ + StreetDirection + ‘ #’Suite 
(if the field that follows has a value use a space separator and # before the suite if there is a suite)

If we don’t have the StreetName, then we are using the cross street mode and would be:

-If cross street 1 and cross street 2 have a value <cross street 1> + ‘ & ‘ + <cross street 2>
-If cross street 1 only has a value <cross street 1>
-If cross street 2 only has a value <cross street 2>

If we dont have StreetName and CrossStreet1 or CrossStreet2
- Common
Else
- LocationNotes

<xsl:template name="SetStreetAddress">
	<xsl:param name="pHouseNumber"/>
	<xsl:param name="pStreetName"/>
	<xsl:param name="pStreetType"/>
	<xsl:param name="pStreetDirection"/>
	<xsl:param name="callCrosStreet1"/>
	<xsl:param name="callCrosStreet2"/>
	<xsl:param name="pCommon"/>
	<xsl:param name="LocationNotes"/>
	<xsl:param name="pSuite"/>
	<xsl:element name="StreetAddress">
		<xsl:variable name="varpHouseNumber">
			<xsl:choose>
				<xsl:when test="$pHouseNumber != ''">
					<xsl:value-of select="concat($pHouseNumber,' ')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="varStreetType">
			<xsl:choose>
				<xsl:when test="$pStreetType != ''">
					<xsl:value-of select="concat(' ',$pStreetType)"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
			<xsl:variable name="varStreetDirection">
			<xsl:choose>
				<xsl:when test="$pStreetDirection != ''">
					<xsl:value-of select="concat(' ',$pStreetDirection)"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:variable name="varSuite">
			<xsl:choose>
				<xsl:when test="$pSuite != ''">
					<xsl:value-of select="concat(' #',$pSuite)"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="''"/>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<xsl:choose>
			<xsl:when test="$pStreetName != ''">
				<xsl:value-of select="concat($varpHouseNumber,$pStreetName,$varStreetType,$varStreetDirection,$varSuite )"/>
			</xsl:when>
			<!-- <xsl:when test="$pFullAddress != ''">
				<xsl:value-of select="$pFullAddress"/>
			</xsl:when> -->
			<xsl:when test="$callCrosStreet1 != '' and  $callCrosStreet2 != ''">
				<xsl:value-of select="concat($callCrosStreet1,' &amp; ',$callCrosStreet2)"/>
			</xsl:when>
			<xsl:when test="$callCrosStreet1 != ''">
				<xsl:value-of select="$callCrosStreet1"/>
			</xsl:when>
			<xsl:when test="$callCrosStreet2 != ''">
				<xsl:value-of select="$callCrosStreet2"/>
			</xsl:when>
			<xsl:when test="$pCommon != ''">
				<xsl:value-of select="$pCommon"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$LocationNotes"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:element>
</xsl:template>

**********************************************************************